WEBVTT

00:04.760 --> 00:11.190
Hello everyone and welcome to part five tuples sets and Bullen's tuple sets and blends are going to

00:11.190 --> 00:15.400
be the last data types are the basic data structures for Python that we're going to be covering.

00:15.450 --> 00:18.870
So we'll just cover them briefly and explain what they are.

00:18.900 --> 00:24.540
Tuples are immutable sequences meaning the kind of act like a list except you can't index something

00:24.540 --> 00:26.000
from a tuple and try to change it.

00:26.000 --> 00:27.210
It's immutable.

00:27.420 --> 00:34.410
Sets are unordered collections of unique elements in booleans just like before are true and false statements.

00:34.410 --> 00:39.900
Let's get started by going to the editor and showing you some quick examples of tuples sets and booleans.

00:39.900 --> 00:46.660
All right let's first just show booleans in Python billions in Python are true with a capital T.

00:47.550 --> 00:56.010
And false with a capital F and as quick note you can also use 0 and 1 if control flow statements but

00:56.190 --> 00:59.820
it's more common to see true and false than just appears 0 or 1.

01:00.030 --> 01:05.930
But sometimes the situation makes more sense to use a numerical boolean value versus true and false

01:06.960 --> 01:07.310
OK.

01:07.340 --> 01:11.530
That's basically it for booleans if you want to learn more about them you can go back to javascript's

01:11.600 --> 01:15.470
section where we explain how to actually use booleans more clearly.

01:15.680 --> 01:20.300
As far as the syntax though it's just a capital-T in capital F when dealing with booleans.

01:20.300 --> 01:22.910
Now tuples are immutable sequences.

01:22.910 --> 01:25.310
So let's cover them real quickly.

01:25.310 --> 01:31.700
You construct a tuple just like you would a list except instead of using square brackets you use princes

01:32.000 --> 01:33.430
and then you create a sequence.

01:33.440 --> 01:39.230
There is a tuple one two three and you can index out of a tuple using the bracket notation like that

01:39.230 --> 01:40.130
for a list.

01:40.130 --> 01:44.450
So if I want the very first item in a tuple that would just be index 0.

01:44.450 --> 01:45.540
So let's show this.

01:45.560 --> 01:48.990
I'm going to say Python and this file is.

01:49.010 --> 01:50.630
No it's not pi.

01:50.720 --> 01:59.290
And here I get one out since I was printing t of 0 tuples can also hold mixed data types just like a

01:59.290 --> 02:00.040
list.

02:00.130 --> 02:15.300
So I could say T is equal to a true hundred 123 save that say print t save it on us that pi.

02:15.410 --> 02:16.640
That's totally fine.

02:16.640 --> 02:22.790
So tuples again is basically like a list except the main difference is that there are immutable.

02:22.790 --> 02:30.880
So if I try to say t of 0 is equal to something new and I run this I'm going to get an error and notice

02:30.880 --> 02:33.670
it says tuple object does not support item assignment.

02:33.760 --> 02:37.460
And that was actually the same error we got when we try to do the same thing with a string.

02:37.540 --> 02:42.340
So both a string and a tuple are immutable a list however is mutable.

02:42.340 --> 02:47.520
So let's change these to be a list by just changing out the brackets.

02:47.580 --> 02:48.920
And now if I try this.

02:49.110 --> 02:53.030
And let's instead of calling it t we'll call it my list.

02:55.190 --> 02:56.160
My list.

02:56.360 --> 03:01.880
And then finally over here my list I run this again.

03:02.180 --> 03:05.900
Now a true and one two three are totally fine.

03:06.080 --> 03:07.940
I successfully ran that.

03:07.940 --> 03:11.410
So let's actually print it out to make sure save it.

03:11.630 --> 03:12.880
Run it in here.

03:12.890 --> 03:16.110
I can see that a list is mutable but a tuple is not.

03:16.130 --> 03:19.770
That's basically all you need to know about a list slicing indexing.

03:19.790 --> 03:23.560
It's all exactly the same between a list and a tuple.

03:23.590 --> 03:24.990
So it's really that.

03:25.090 --> 03:27.220
And now finally let's discuss sets.

03:27.220 --> 03:31.860
So sets are unordered collections of unique elements.

03:31.860 --> 03:36.040
Now we can construct a set by calling the set keyword.

03:36.040 --> 03:43.410
I can say set are x is equal to set close print CS and then if I want to add something to the set I

03:43.410 --> 03:47.610
can use the Add method and you can see here the list of methods available.

03:47.780 --> 03:56.880
But I will say add one to the set and then I will add to the set and then I'm going to print the set.

03:56.950 --> 03:59.580
So let's save this and see what happens.

04:00.010 --> 04:01.100
So here I have my set.

04:01.100 --> 04:06.190
Want to know how it has the curly brackets so it looks very similar to a dictionary except there aren't

04:06.190 --> 04:07.590
key value pairs here.

04:07.750 --> 04:09.380
It's just a bunch of elements.

04:09.400 --> 04:12.510
And remember for a set the elements are an order.

04:12.610 --> 04:14.350
So it has no particular order.

04:14.350 --> 04:18.030
If I print out x another time it may come out in either way.

04:18.070 --> 04:26.550
So let's add some more elements to a set such as for let's do 0.1 loops.

04:26.590 --> 04:32.040
I need to add that save this round this again.

04:32.040 --> 04:33.930
0.1 1 2 and 4.

04:33.930 --> 04:38.390
So notice that it's coming out in a different way than I had actually imported.

04:38.580 --> 04:40.860
And don't be fooled that they come out sorted.

04:40.860 --> 04:44.360
That's not exactly how the set is putting them in.

04:44.460 --> 04:47.370
So it doesn't send them out in any sort of sorting order.

04:47.370 --> 04:51.390
It's always an unordered collection of elements unique elements.

04:51.390 --> 04:53.400
So let's focus on that unique aspect.

04:53.400 --> 04:55.260
So what does it actually mean by unique.

04:55.440 --> 05:05.140
Well I'm going to try adding the similar elements multiple times so I will try to add four again and

05:05.140 --> 05:07.760
say X add 4 again.

05:07.900 --> 05:09.030
Now a set.

05:09.280 --> 05:12.880
When you run this it's only going to put out 1 2 and 4.

05:12.940 --> 05:18.370
Even though I added for three separate times the reason for that is because it only takes in unique

05:18.460 --> 05:19.410
elements.

05:19.450 --> 05:24.000
So once an element is in the set that's it you can't keep adding it multiple times.

05:24.010 --> 05:31.200
It's only unique elements which makes a set call really convenient to call on a list of multiple elements.

05:31.210 --> 05:39.600
So if I have a list of repeated elements like this one so I see the brackets here this side is a list.

05:39.610 --> 05:43.590
Nice do a set call on that list and let's print it out.

05:44.400 --> 05:52.490
So now I'm going to save this as let's call it converted because I'm converting a list into a set and

05:52.490 --> 05:59.620
then I say print out converted will save this and then run this.

05:59.730 --> 06:01.350
And now I can see I get 1 to 4.

06:01.350 --> 06:08.310
That was X and converted I got this whole list with multiple elements to just be one to three.

06:08.310 --> 06:08.850
OK.

06:09.090 --> 06:14.820
That's really all we need to know now about booleans sets and tuples later on when we cover for loops

06:14.820 --> 06:19.410
We'll talk about tuple and unpacking a little bit which is really common with Python sets.

06:19.410 --> 06:23.370
We won't be seeing them too much throughout the course booleans we'll see those all the time.

06:23.370 --> 06:26.530
So keep those in mind as we continue on through the course.

06:26.700 --> 06:28.200
Thanks and I'll see you at the next lecture.
