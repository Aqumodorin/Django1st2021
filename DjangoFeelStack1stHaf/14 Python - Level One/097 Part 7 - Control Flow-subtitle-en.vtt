WEBVTT

00:04.770 --> 00:06.600
Hello everyone and welcome to part 7.

00:06.600 --> 00:12.150
Control flow in this lecture are going to be discussed in the Python syntax for control flow and this

00:12.150 --> 00:13.560
will include operators.

00:13.560 --> 00:19.110
If LCF and statements and loops like for loops and while loops we will cover the main principles behind

00:19.110 --> 00:20.050
these topics.

00:20.070 --> 00:24.660
Hopefully you remember them from the javascript lectures will just cover the general syntax and what

00:24.660 --> 00:29.760
makes Python a little bit different than the programming languages for some of these control flow operators.

00:29.760 --> 00:31.650
OK let's get started.

00:31.650 --> 00:36.150
All right so let's begin our discussion of comparison operators and logical operators that have copied

00:36.150 --> 00:39.630
and pasted here from the notes because we will need to code that much.

00:39.630 --> 00:41.290
A lot of it's pretty straightforward.

00:41.430 --> 00:47.060
So for greater then you just use the greater sign or greater than sign less then is the less than sign

00:47.500 --> 00:52.740
you have greater than or equal to Lessner equal to and then free quality is a little different than

00:52.740 --> 00:54.420
it was for Javascript.

00:54.420 --> 01:01.260
So there is no triple equal sign in Python because Python will automatically check for types to be different

01:01.260 --> 01:04.930
or the same still Micheaux an example of what I mean by that.

01:04.980 --> 01:11.360
So here I'm going to say one equals equals one and it's true.

01:11.460 --> 01:16.540
But if I say one equals equals and then I pass a string one I get false.

01:16.560 --> 01:21.260
So there is no type coercion in python like there was in Javascript.

01:21.540 --> 01:27.930
So if I say hi is equal to by then this is a really clear case where it should be false.

01:27.930 --> 01:33.840
OK so again for Python it's just going to be two sets of equal sign and for any equality is just an

01:33.840 --> 01:35.010
exclamation mark.

01:35.190 --> 01:37.890
So you can say one not equal to one.

01:37.890 --> 01:42.140
That's false one not equal to the string one.

01:42.210 --> 01:43.780
That is true.

01:43.950 --> 01:46.370
Now to discuss logical operators of Python.

01:46.680 --> 01:48.930
I think this is one of the coolest parts about Python.

01:48.930 --> 01:53.730
The logical operators are just literally the words and and or.

01:53.880 --> 01:55.720
So that makes reading logical operators.

01:55.720 --> 01:58.410
Python really simple even if you have a program for it.

01:58.510 --> 02:01.410
There's no ampersand or pipe operators here.

02:01.410 --> 02:04.270
So again that's just the keyword and the keyword.

02:04.290 --> 02:10.770
Or you can have multiple logical operators like this or an or.

02:10.770 --> 02:12.200
Now let's move on to discuss.

02:12.240 --> 02:18.120
If Elif and L statements or else if statements and before we begin to talk about that.

02:18.120 --> 02:22.870
Something to note with Python that's going to differentiate itself from other languages.

02:22.900 --> 02:27.630
Is that indentation is extremely important in Python and it's basically Python's way of getting rid

02:27.630 --> 02:28.940
of enclosing brackets.

02:29.170 --> 02:34.320
So a lot of other languages you're going to be using in closing brackets a lot as we saw javascript.

02:34.320 --> 02:37.250
These don't really occur in Python.

02:37.260 --> 02:43.320
The reason for that is because Python really stresses readability due to whitespace and that whitespace

02:43.320 --> 02:44.770
comes from indentation.

02:44.790 --> 02:46.880
So let me show you some examples of if.

02:46.950 --> 02:51.730
Elif and else statements if ought to have an if statement.

02:51.790 --> 02:56.220
And let's actually quit python here so that I can run this code.

02:56.560 --> 03:06.260
I will clear my screen and then what I'm going to do is say if one is less than two and then a colon

03:06.350 --> 03:09.830
indicates the code block and hit enter here.

03:09.830 --> 03:12.230
Note that it automatically indents for me.

03:12.230 --> 03:18.260
And if your work if any ID either recognizes python files it should automatically indent for you.

03:18.480 --> 03:23.720
And then I'm going say Prince Yes.

03:23.770 --> 03:28.530
So now if I run this I'll say Python notes.

03:28.620 --> 03:31.750
PI enter and I get a yes output.

03:31.750 --> 03:33.020
So the main features here.

03:33.040 --> 03:38.560
We can zoom in a little more and make this really clear is for any control flow statement.

03:38.560 --> 03:41.650
With Python you have the keyword operator.

03:41.680 --> 03:44.720
Here it's if we'll see ELSE IN FOR loops etc..

03:44.920 --> 03:46.760
You don't need to worry about print C's here.

03:46.780 --> 03:52.100
You just type in whatever you want to actually compare or whatever the boolean operator is.

03:52.120 --> 03:58.000
Then a colon here indicates that you're going to start a new code block and then the code block itself

03:58.090 --> 04:03.150
is indented in everything that's indented at same level belongs to the same code block.

04:03.190 --> 04:05.600
So if I want to have a nested IF statement.

04:05.800 --> 04:20.560
So for instance if two is less than three Crantz.

04:20.660 --> 04:22.290
So let's save this in.

04:22.550 --> 04:27.280
Let's zoom back out a little bit so this isn't so massively as him then.

04:27.290 --> 04:31.370
And then let's actually run this and we get true.

04:31.750 --> 04:41.450
So now let's make one of these false so I won't say if 20 is less than 3 and then I'm going to print

04:42.830 --> 04:48.790
first block here and let's change this to say second block.

04:49.070 --> 04:50.440
So what's going to happen here.

04:50.450 --> 04:55.680
First off in order to run anything that's indented Pass Line 1.

04:55.730 --> 04:56.690
This has to be true.

04:56.720 --> 04:58.210
One has to be less than two.

04:58.310 --> 05:00.570
So then we go along we see Prince first block.

05:00.580 --> 05:01.590
So that is true.

05:01.910 --> 05:03.950
Then it goes to line 3.

05:03.980 --> 05:06.450
If 20 is less than 3 that's not true.

05:06.500 --> 05:09.830
Nothing is going to occur in line for all x Q..

05:09.860 --> 05:14.510
So now if I run this I get first block only.

05:14.520 --> 05:20.070
So again hopefully you can begin to see how the indentation works here and this block of code is indented

05:20.070 --> 05:23.070
at same level so it runs together.

05:23.070 --> 05:24.950
And then this block of code is indented in.

05:24.950 --> 05:27.820
So this is the top level for this block of code.

05:27.870 --> 05:31.170
So again it's just a colon an indentation.

05:31.170 --> 05:34.080
OK so that's the basics of an IF statement.

05:34.140 --> 05:37.330
Let's see if else statement I can say something like.

05:37.350 --> 05:46.900
If one is less than two prints hello and then if I want an else to be attached if statement.

05:46.930 --> 05:59.240
All I have to do is line it up so that I will say else colon Crantz last Let's just say last save and

05:59.260 --> 06:00.350
run the notes here.

06:00.580 --> 06:02.450
And I said hello to print.

06:02.600 --> 06:06.800
Now this changes so that is one greater than two which is not true.

06:06.830 --> 06:14.390
So if I run this then I get last Again main idea here is you have a colon instead of the curly brackets

06:14.510 --> 06:19.420
and the parentheses from other programming languages.

06:19.470 --> 06:25.140
And then finally if you want to add a more conditional checks like an else if in Javascript you just

06:25.140 --> 06:28.440
use a single phrase Ilive which is short for else.

06:28.450 --> 06:31.900
If so I can do something like this.

06:34.700 --> 06:39.890
Elif and then some condition here so ilah three equals three

06:43.320 --> 06:46.620
Crantz Elif Ramm

06:49.430 --> 06:56.590
we save this and I want to run Python notes it sets ilah Fran nuts because this first condition wasn't

06:56.590 --> 06:59.150
true and this Ilive condition was true.

06:59.200 --> 07:01.240
So what's happening here.

07:01.240 --> 07:04.710
These are all lined up together on their indentation.

07:04.990 --> 07:15.580
So if I have something let's say if one is equal to one colon I could grab all of this and it hit tab.

07:15.930 --> 07:18.500
And now these are all lined up for each other.

07:18.500 --> 07:25.960
So a note here indentation is really making it clear which code blocks belong to which conditional checks.

07:25.970 --> 07:28.570
All right so that's the very basics of if.

07:28.580 --> 07:31.520
Elif and L statements with Python again.

07:31.550 --> 07:37.640
Really want to point out here the whitespace in the colon is what's the finding code blocks instead

07:37.640 --> 07:41.450
of like normal programming languages where you have parentheses and brackets.

07:41.480 --> 07:46.950
And this really emphasizes how fast you can code of Python how readable Python is and how much time

07:46.950 --> 07:50.560
we're going to save working of Python versus other languages.

07:50.990 --> 07:55.720
Ok so now let's go ahead and move on to a big topic which is Loups.

07:55.940 --> 08:02.540
We've already covered loops in javascript so we won't define here the general principles behind loops

08:02.540 --> 08:05.810
will just show you the syntax for working with them with Python.

08:05.810 --> 08:07.650
So first off are for loops.

08:08.950 --> 08:13.910
And for loops are going to behave a little differently depending on what you're working with in Python.

08:14.010 --> 08:18.210
So usually you're going to be using a for loop with a sequence and a sequence can be something like

08:18.230 --> 08:19.300
a list.

08:19.350 --> 08:27.600
So let's create a sequence 1 2 3 4 5 6 and the for loop syntax for Python looks like this.

08:27.600 --> 08:38.710
You say for some item in the sequence colon and then what ever you do is code here.

08:38.710 --> 08:43.000
So then let's just say prints the item.

08:43.110 --> 08:48.660
So hopefully it looks a little familiar from the four of or four loops in javascript and if I run this

08:48.660 --> 08:55.560
year I get 1 2 3 4 5 6 so you can see I kept printing it every line or what I could also do is say prints

08:56.420 --> 08:57.200
hello.

08:57.300 --> 09:00.050
So if I save that and run this I get.

09:00.060 --> 09:01.130
Hello hello hello.

09:01.140 --> 09:06.140
For each item in the sequence and I can call this whatever I want doesn't have to be item.

09:06.270 --> 09:12.810
So I always make this really obvious by saying something like jelly and then I'm going to print jelly

09:12.810 --> 09:13.570
every time.

09:13.590 --> 09:14.760
Save that.

09:14.760 --> 09:18.700
Run this and I get back all the numbers in that sequence.

09:18.870 --> 09:20.520
OK hopefully it's pretty clear.

09:20.590 --> 09:26.540
It's just for whatever variable you want in the sequence.

09:26.580 --> 09:30.520
And then you do some action for each of those variables.

09:30.540 --> 09:33.540
OK so that's how you iterate through a list.

09:33.700 --> 09:36.250
If you end up calling a for loop on a dictionary.

09:36.250 --> 09:42.480
So let's make that let's say D is equal to Sam

09:45.060 --> 10:00.880
1 and let's say Frank is to and Dan is three if I say for item in D and say prints.

10:00.910 --> 10:06.520
Item if I save that and then see what this looks like it ends up printing out the keys.

10:06.520 --> 10:08.130
Sam Dan and Frank.

10:08.140 --> 10:11.410
But notice it's not it's not printing them out in order.

10:11.410 --> 10:14.650
And remember that's because dictionaries don't retain any sort of order.

10:14.710 --> 10:20.980
So if you're ever going to use a for loop of a dictionary don't count on it happening in order if you

10:20.980 --> 10:25.540
actually wanted to get the keys out what you should do is something like this you can say for K

10:28.300 --> 10:37.950
and since we are just printing out these we can say print the key and then print the key.

10:38.130 --> 10:44.700
And this is how you can print out if I run this what Dan is three Frank to Sam is one again orders not

10:44.710 --> 10:48.480
ever going to be the same when you're going through dictionary.

10:48.500 --> 10:54.770
There are also methods you can call off a dictionary for to get all the items are all the keys so I

10:54.770 --> 11:02.930
could say the values to get all the values that key is to get all the keys etc. but we won't actually

11:02.930 --> 11:05.230
cover those right now if we ever use them in Django.

11:05.330 --> 11:07.100
I'll be sure to clarify what we're doing there.

11:07.100 --> 11:12.090
But again dictionary and with for loops it's automatically going to be the keys.

11:12.100 --> 11:12.540
All right.

11:12.640 --> 11:14.090
Let's delete that.

11:14.620 --> 11:19.450
And now let's talk about iterating through a tuple an about tuple and packing.

11:19.450 --> 11:25.330
So a lot of times built in functions in Python are going to end up giving you structures that look like

11:25.330 --> 11:25.830
this.

11:25.850 --> 11:32.120
It will be a list and inside of that lists you'll have tuples that look like this.

11:32.120 --> 11:36.060
So one two five six so what do I have here.

11:36.110 --> 11:39.760
I have a list of three tuples.

11:39.920 --> 11:51.640
So if I say for item in my pairs prints item I'm going to save this run it.

11:52.070 --> 11:56.290
I get each tuple out one two three four five six.

11:56.630 --> 12:03.110
But what I can also do and this is a special case is if I have a sequence that consists of tuples I

12:03.110 --> 12:09.350
can do what is known as tuple and a packing of Python so I can kind of type A tuple here and say something

12:09.350 --> 12:22.080
like Type 1 to 2 and then I'm going to print to you P1 and then I will print to you too.

12:22.190 --> 12:23.150
So if I save that.

12:23.150 --> 12:27.720
Basically what happens here is I'm unpacking that tuple in my for loop.

12:27.860 --> 12:35.210
So I run this and I can get one two three four five six or if I switch up the order here I should get

12:36.510 --> 12:39.480
to 1 4 3 6 5.

12:39.480 --> 12:40.680
So let's do that.

12:40.920 --> 12:48.540
Save it run this and I get to 1 4 3 6 5 because it's printing out the second item and tuple and then

12:48.540 --> 12:50.470
the first item in the table.

12:50.610 --> 12:53.400
So that is tuple and packing and you usually don't see it.

12:53.400 --> 12:57.180
These princes usually see it just like this.

12:57.210 --> 13:02.310
So if you ever see something like this don't be confused or intimidated it's just to pull in packing

13:02.520 --> 13:06.120
and this sort of formatting is really commonly used in Python.

13:06.120 --> 13:09.870
So tuple Impac is definitely something we'll be working on if in the future.

13:09.870 --> 13:10.370
OK.

13:10.530 --> 13:13.260
So that's really all you need to know about for loops.

13:13.440 --> 13:16.450
Let's quickly discuss while loops with Python.

13:17.200 --> 13:18.740
I'm going to delete this.

13:19.100 --> 13:23.500
So while loops again allow us to continually perform an action until a condition becomes true.

13:23.840 --> 13:25.820
And it's really simple.

13:25.850 --> 13:26.960
I'll show you a quick example.

13:26.960 --> 13:28.550
Say is equal to 1.

13:28.820 --> 13:38.580
And then we will say while I is less than five then colon that indicates the code block will say Prince

13:40.590 --> 13:53.780
is and always print formatting here ass and I and then we will say I's equal to I plus one.

13:53.790 --> 13:55.710
So again really simple example.

13:56.040 --> 13:57.480
Let's clear this.

13:57.480 --> 14:04.260
If I run Python it's again says eyes one eyes two eyes three eyes four and then once I get to five it's

14:04.260 --> 14:05.430
no longer less than five.

14:05.430 --> 14:06.720
So the while loop breaks.

14:06.750 --> 14:09.090
So it's just a colon in a white space in the cane.

14:09.090 --> 14:17.000
The loop now is quickly discuss a few more useful topics to know since we're talking about control flow.

14:17.040 --> 14:22.590
One of them is the range function and range functions can quickly generate integers for you based on

14:22.590 --> 14:24.390
a starting point and an ending point.

14:25.400 --> 14:32.840
So if I do something like well let's actually show this with Python over here directly in the command

14:32.840 --> 14:34.060
prompt.

14:34.070 --> 14:42.290
So if I do something like one two three four five I have a list that goes from 1 all the way to five

14:43.070 --> 14:47.890
but I can use range to help me out in Python 3 if I just type Prange 5.

14:47.960 --> 14:51.010
I get back this range zero to 5 object.

14:51.020 --> 15:01.490
What I have to do is say list range 0 5 and then actually get backlist 0 1 2 3 4 where the first parameter

15:01.580 --> 15:07.800
in range is the starting index position and the second one is D and index position.

15:07.940 --> 15:15.750
And I can add a third argument indicating a step size so I can say list range and let's go from zero.

15:17.400 --> 15:20.150
20 and then I'm going to type in two.

15:20.270 --> 15:28.580
I hit enter and I get all the even numbers that go up to but not including index 20 and try to remember

15:28.580 --> 15:30.530
back to slice notation.

15:30.530 --> 15:32.240
Sometimes students are confused.

15:32.270 --> 15:36.020
They expect a 20 to show up here but it's not including 20.

15:36.020 --> 15:39.680
So if we wanted 20 we would have to say 21.

15:39.860 --> 15:41.660
We have to say one greater there.

15:41.670 --> 15:42.480
All right.

15:42.500 --> 15:48.650
Now another question you might be thinking is well what is range 0 5.

15:48.650 --> 15:52.170
What is that and why did it return that that is a generator.

15:52.190 --> 15:58.420
And basically what that means is it's going to generate the items or elements in this list.

15:58.460 --> 16:02.370
Instead of saving it all to a list and that saves your computer memory.

16:02.390 --> 16:08.840
So instead of having to store this entire huge list in memory cause let's say you had range and then

16:08.840 --> 16:13.610
some humungous number you wouldn't want your computer to have to save this entire list if you're just

16:13.610 --> 16:19.130
going to iterate through it what you want is just a generator where it remembers the previous number

16:19.370 --> 16:25.610
and then adds 1 and then saves that previous number adds one saves it and keeps the leading sort of

16:25.610 --> 16:30.800
only has one number in memory at a time and it knows the formula to get to the next number.

16:30.800 --> 16:34.970
So for instance it would say I remember to add two to it to get four.

16:35.090 --> 16:35.910
Get rid of two.

16:35.930 --> 16:37.280
Now my current numbers for.

16:37.440 --> 16:38.510
Oh you want the next number.

16:38.510 --> 16:39.720
Add two to it.

16:39.710 --> 16:40.550
Now have six.

16:40.550 --> 16:42.110
Get rid of four from memory.

16:42.140 --> 16:44.510
And that way we go along just remembering one number.

16:44.570 --> 16:46.350
That's kind of the idea behind a generator.

16:46.610 --> 16:56.290
So you can actually then use something like for item in range and usually see something like 10

16:59.540 --> 17:05.240
Crantz item we'll save that and then let's quit python here.

17:06.070 --> 17:06.910
Call Python.

17:06.930 --> 17:09.960
It's not pie and here you can see I'm getting 0 1 2 3.

17:10.120 --> 17:11.200
All the way up to nine.

17:11.200 --> 17:15.840
So it doesn't include 10 or remember only goes up to nine here OK.

17:15.840 --> 17:18.290
Now let's quickly recover list comprehension.

17:18.290 --> 17:19.360
We mentioned that before.

17:19.370 --> 17:25.530
But let's show you a more practical example Now imagine I have the list x is equal to 1 2 3 4 and I

17:25.530 --> 17:28.280
want to create a list of those items squared.

17:28.680 --> 17:36.840
I could make an empty output list just with empty brackets there and say for numb an X.

17:36.840 --> 17:48.230
So in my list x take out and then appends to the power of two and then say print the output and note

17:48.230 --> 17:54.410
that the print out is lined up with four meaning it's going to occur after this entire four loop ran.

17:54.470 --> 17:58.040
So I will save this run Python notes that pi.

17:58.190 --> 18:01.180
And here I can see I get 1 4 9 16.

18:01.220 --> 18:03.390
So that's how you would do this normal for a loop.

18:03.590 --> 18:08.330
But if you ever find yourself running a for loop like this and always appending something to a list

18:08.870 --> 18:14.100
from another sequence or another list the way you can do this is write this as a list comprehension.

18:14.480 --> 18:18.960
And what you do is you essentially break down this for loop.

18:19.010 --> 18:26.370
So we take the original X here and it says Fortnum in X we changed this out.

18:26.570 --> 18:30.020
We get rid of it completely change here.

18:30.320 --> 18:39.190
Make this into a bracket and then make what we have on the append go in fronts of the four and that

18:39.370 --> 18:41.440
is the basics of a list comprehension.

18:41.470 --> 18:48.510
It's just the for loop rewritten and the flattened form and then we can say call this whole thing out.

18:49.570 --> 18:50.750
Whoops.

18:50.960 --> 18:52.780
And then let's print it.

18:52.900 --> 19:02.150
Say print out save it run this and we get 1 4 9 16 and those are the basics of a list comprehension.

19:02.150 --> 19:04.120
OK that was control flow of Python.

19:04.130 --> 19:07.280
Do you have any questions feel free to post to the Usenet forums.

19:07.280 --> 19:08.780
Thanks and I'll see at the next lecture.
